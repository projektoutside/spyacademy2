<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="The Spy Academy">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000511">
    <meta name="msapplication-navbutton-color" content="#000511">
    
    <!-- Performance and compatibility -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    
    <title>The Spy Academy - Escape Room</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3EðŸ’Ž%3C/text%3E%3C/svg%3E">
    
    <!-- Apple Touch Icon -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect width='180' height='180' fill='%23000511'/%3E%3Ctext x='90' y='120' font-size='80' text-anchor='middle' fill='%2300ffff'%3EðŸ’Ž%3C/text%3E%3C/svg%3E">
    
    <!-- PWA Manifest (only for served content) -->
    <script>
        if (location.protocol !== 'file:') {
            const manifestLink = document.createElement('link');
            manifestLink.rel = 'manifest';
            manifestLink.href = 'manifest.json';
            document.head.appendChild(manifestLink);
        }
    </script>
    
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <script>
        /**
         * Main Application Initialization
         * Simplified for better reliability
         */
        
        // Game State and Configuration (from root index.html)
        const GameState = {
            players: [],
            playerCount: 0,
            currentPlayerIndex: 0,
            roles: {},
            gamePhase: 'main-menu',
            votes: {},
            rpsRound: 1,
            goodScore: 0,
            badScore: 0,
            maxScore: 3,
            currentLeader: 'good',
            skipFirstImpressions: false,
            audioEnabled: true,
            sfxEnabled: true,
            voiceEnabled: true,
            currentScene: 'main-menu'
        };

        // Create App namespace for better organization
        window.LightChallengeApp = {
            initialized: false,
            audioContextStarted: false,
            resizeTimer: null,
            
            // Initialize the application
            async init() {
                if (this.initialized) return;
                
                try {
                    // Wait for basic utilities
                    await this.waitForUtilities();
                    
                    // Use logger for initialization
                    window.logger?.info('The Spy Academy - Initializing...');
                    
                    // Set up device-specific optimizations
                    this.setupDeviceOptimizations();
                    
                    // Set up first user interaction handlers
                    this.setupFirstInteractionHandlers();
                    
                    // Initialize sound manager first (simplified)
                    await this.initializeSoundManager();
                    
                    // Set up UI controls
                    this.setupUIControls();
                    
                    // Show main menu
                    await this.showMainMenu();
                    
                    this.initialized = true;
                    window.logger?.info('Game initialized successfully');
                    
                } catch (error) {
                    window.logger?.error('Failed to initialize application', error);
                    this.showError('Failed to initialize the game. Please refresh the page.');
                }
            },
            
            // Wait for utilities to load
            async waitForUtilities() {
                let attempts = 0;
                const maxAttempts = 30; // 3 seconds max wait
                
                while (!window.logger && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (!window.logger) {
                    console.warn('Utilities not loaded in time, continuing without them');
                }
            },
            
            // Enhanced device-specific optimizations for perfect adaptability
            setupDeviceOptimizations() {
                const config = window.gameConfig;
                
                // Enhanced viewport height fix for all mobile devices
                const setViewportUnits = () => {
                    // Set CSS custom properties for perfect viewport handling
                    const vh = window.innerHeight * 0.01;
                    const vw = window.innerWidth * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    document.documentElement.style.setProperty('--vw', `${vw}px`);
                    
                    // Additional safe area handling for notched devices
                    const safeAreaTop = getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-top)') || '0px';
                    const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('env(safe-area-inset-bottom)') || '0px';
                    document.documentElement.style.setProperty('--safe-area-top', safeAreaTop);
                    document.documentElement.style.setProperty('--safe-area-bottom', safeAreaBottom);
                };
                
                // Initial setup
                setViewportUnits();
                
                // Enhanced event listeners for all device types
                window.addEventListener('resize', () => {
                    clearTimeout(this.resizeTimer);
                    this.resizeTimer = setTimeout(setViewportUnits, 100);
                });
                
                window.addEventListener('orientationchange', () => {
                    // Multiple timeout approach for better device compatibility
                    setTimeout(setViewportUnits, 100);
                    setTimeout(setViewportUnits, 300);
                    setTimeout(setViewportUnits, 500);
                });
                
                // Device-specific optimizations
                this.setupDeviceSpecificFixes(config);
                
                // Universal touch optimizations
                this.setupUniversalTouchOptimizations();
                
                // Performance optimizations
                this.setupPerformanceOptimizations();
            },
            
            // Device-specific fixes for maximum compatibility
            setupDeviceSpecificFixes(config) {
                // iOS-specific fixes
                if (config?.device.isIOS) {
                    // Prevent zoom on iOS
                    document.addEventListener('gesturestart', (e) => e.preventDefault());
                    document.addEventListener('touchstart', (e) => {
                        if (e.touches.length > 1) e.preventDefault();
                    }, { passive: false });
                    
                    // Fix iOS Safari viewport issues
                    document.addEventListener('touchend', () => {
                        if (document.activeElement.tagName !== 'INPUT') {
                            document.activeElement.blur();
                        }
                    });
                }
                
                // Android-specific fixes
                const isAndroid = /Android/i.test(navigator.userAgent);
                if (isAndroid || config?.device.isAndroid) {
                    // Fix Android keyboard issues
                    window.addEventListener('resize', () => {
                        if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                            setTimeout(() => {
                                document.activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }, 300);
                        }
                    });
                }
                
                // Samsung Internet fixes
                if (navigator.userAgent.includes('SamsungBrowser')) {
                    document.body.style.setProperty('-webkit-overflow-scrolling', 'touch');
                }
                
                // Windows Phone fixes (legacy support)
                if (navigator.userAgent.includes('Windows Phone')) {
                    document.body.style.setProperty('-ms-touch-action', 'manipulation');
                }
            },
            
            // Universal touch optimizations
            setupUniversalTouchOptimizations() {
                // Enhanced touch handling for all devices
                const touchElements = 'button, .clickable, .player-btn, .color-option, .submit-btn, .clear-btn';
                
                // Add touch feedback to all interactive elements
                document.addEventListener('touchstart', (e) => {
                    if (e.target.matches(touchElements)) {
                        e.target.style.setProperty('--touch-active', '1');
                        e.target.classList.add('touch-active');
                    }
                }, { passive: true });
                
                document.addEventListener('touchend', (e) => {
                    if (e.target.matches(touchElements)) {
                        setTimeout(() => {
                            e.target.style.removeProperty('--touch-active');
                            e.target.classList.remove('touch-active');
                        }, 150);
                    }
                }, { passive: true });
                
                // Prevent context menu on long press for game elements
                document.addEventListener('contextmenu', (e) => {
                    if (e.target.matches(touchElements)) {
                        e.preventDefault();
                    }
                });
            },
            
            // Performance optimizations for all devices
            setupPerformanceOptimizations() {
                // Optimize scroll performance
                let supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, 'passive', {
                        get: function() {
                            supportsPassive = true;
                            return false;
                        }
                    });
                    window.addEventListener('testPassive', null, opts);
                    window.removeEventListener('testPassive', null, opts);
                } catch (e) {}
                
                if (supportsPassive) {
                    document.addEventListener('touchstart', () => {}, { passive: true });
                    document.addEventListener('touchmove', () => {}, { passive: true });
                }
                
                // Optimize animation performance
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => {
                        // Non-critical operations can be moved here
                        this.optimizeForDevice();
                    });
                }
                
                // Memory management for mobile devices
                try {
                    if (navigator.deviceMemory && navigator.deviceMemory < 4) {
                        // Reduce visual effects for low-memory devices
                        document.documentElement.classList.add('reduced-effects');
                    }
                } catch (e) {
                    // deviceMemory not supported, continue silently
                }
            },
            
            // Device-specific optimizations
            optimizeForDevice() {
                try {
                    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    
                    // Optimize based on connection speed
                    if (connection && connection.effectiveType) {
                        if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
                            document.documentElement.classList.add('slow-connection');
                        }
                    }
                    
                    // Optimize based on hardware
                    if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) {
                        document.documentElement.classList.add('low-performance');
                    }
                } catch (e) {
                    // Connection API not supported, continue silently
                }
            },
            
            // Set up handlers for first user interaction
            setupFirstInteractionHandlers() {
                const handleFirstInteraction = async (e) => {
                    try {
                        if (!this.audioContextStarted) {
                            window.logger?.audio('First user interaction detected from:', e.type);
                            
                            // Wait for sound manager if it's not ready yet
                            let attempts = 0;
                            while (!window.soundManager && attempts < 10) {
                                await new Promise(resolve => setTimeout(resolve, 100));
                                attempts++;
                            }
                            
                            // **AUDIO CONTEXT FIX: Only handle audio context preparation, NO music here**
                            if (window.soundManager && typeof window.soundManager.resumeAudioContext === 'function') {
                                try {
                                    await window.soundManager.resumeAudioContext();
                                    this.audioContextStarted = true;
                                    window.logger?.audio('Audio context ready for perfect music timing');
                                    
                                    // **CRITICAL: NO intro music logic here to prevent duplicates and timing issues**
                                    // Intro music will ONLY be handled by start button for perfect timing
                                    
                                    // **VOICE FIX: Initialize VoiceManager with realistic Web Speech API**
                                    if (!window.audioManager) {
                                        if (typeof VoiceManager !== 'undefined') {
                                            window.audioManager = new VoiceManager();
                                            window.logger?.audio('VoiceManager initialized with realistic Web Speech API');
                                        } else {
                                            window.logger?.warn('VoiceManager class not loaded yet');
                                        }
                                    }
                                    
                                } catch (error) {
                                    window.logger?.warn('Could not start audio context on first interaction:', error);
                                }
                            } else {
                                window.logger?.info('Sound manager not ready yet, will try again later');
                            }
                        }
                    } catch (error) {
                        window.logger?.error('Error in first interaction handler:', error);
                    }
                };
                
                // Listen for first user interactions with multiple event types for compatibility
                const options = { once: true, passive: true };
                const activeOptions = { once: true, passive: false };
                
                // Add event listeners with error handling
                try {
                    document.addEventListener('click', handleFirstInteraction, activeOptions);
                    document.addEventListener('touchstart', handleFirstInteraction, options);
                    document.addEventListener('touchend', handleFirstInteraction, options);
                    document.addEventListener('pointerdown', handleFirstInteraction, activeOptions);
                    document.addEventListener('keydown', handleFirstInteraction, activeOptions);
                    
                    window.logger?.info('First interaction handlers set up for iPad audio context');
                } catch (error) {
                    window.logger?.error('Failed to set up first interaction handlers:', error);
                }
            },
            
            // Initialize sound manager first (simplified)
            async initializeSoundManager() {
                try {
                    window.logger?.info('Starting sound manager initialization...');
                    
                    // Only try to create sound manager if class exists
                    if (typeof SoundManager !== 'undefined' && !window.soundManager) {
                        window.soundManager = new SoundManager();
                        window.logger?.info('Sound manager created successfully');
                    } else if (!window.soundManager) {
                        window.logger?.warn('SoundManager class not available');
                    }
                    
                    // Small delay for initialization
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                } catch (error) {
                    window.logger?.error('Sound manager creation failed:', error);
                    // Continue without sound
                }
            },
            
            // Set up UI controls
            setupUIControls() {
                this.setupVolumeControls();
                // Could add other UI setup here
            },
            
            // Show main menu with animation
            async showMainMenu() {
                const helpers = window.gameHelpers;
                const config = window.gameConfig;
                
                // Hide loading screen - simplified
                const loading = document.getElementById('loading-screen');
                if (loading) {
                    window.logger?.info('Hiding loading screen...');
                    loading.style.display = 'none';
                    loading.style.opacity = '0';
                    loading.style.visibility = 'hidden';
                    window.logger?.info('Loading screen hidden');
                }
                
                // Show main menu - simplified to ensure it works
                const mainMenu = document.getElementById('main-menu');
                if (mainMenu) {
                    window.logger?.info('Showing main menu...');
                    mainMenu.style.display = 'block';
                    mainMenu.style.opacity = '1';
                    mainMenu.classList.add('active');
                    
                    // Ensure it's visible and in front
                    mainMenu.style.visibility = 'visible';
                    mainMenu.style.zIndex = '1000';
                    
                    window.logger?.info('Main menu should now be visible');
                    
                    // Initialize 3D scene for visual effects (simplified)
                    try {
                        this.initialize3DScene();
                    } catch (e) {
                        window.logger?.warn('3D scene initialization failed:', e);
                    }
                    
                    // Try to start ambient/intro sounds if available (simplified)
                    try {
                        this.initializeIntroSounds();
                    } catch (e) {
                        window.logger?.warn('Intro sounds initialization failed:', e);
                    }
                    
                    // Set up start button interaction - simplified for better cross-platform compatibility
                    const startButton = document.getElementById('start-game-btn');
                    if (startButton) {
                        let gameStarted = false;
                        
                        const startGame = async () => {
                            if (gameStarted) return;
                            gameStarted = true;
                            
                            window.logger?.info('Start game triggered');
                            
                            // Audio initialization with music playback
                            try {
                                if (window.soundManager) {
                                    // Resume audio context first
                                    if (typeof window.soundManager.resumeAudioContext === 'function') {
                                        await window.soundManager.resumeAudioContext();
                                        this.audioContextStarted = true;
                                        window.logger?.audio('Audio context resumed');
                                    }
                                    
                                    // Start intro music after audio context is ready
                                    if (typeof window.soundManager.playRandomIntroMusic === 'function') {
                                        window.logger?.audio('Starting intro music...');
                                        // Small delay to ensure audio context is fully ready
                                        setTimeout(() => {
                                            window.soundManager.playRandomIntroMusic();
                                            window.logger?.audio('Intro music should now be playing');
                                        }, 100);
                                    } else {
                                        window.logger?.warn('playRandomIntroMusic function not available');
                                    }
                                } else {
                                    window.logger?.warn('Sound manager not available - attempting to initialize...');
                                    // Try to initialize sound manager
                                    if (typeof SoundManager !== 'undefined') {
                                        window.soundManager = new SoundManager();
                                        setTimeout(() => {
                                            if (window.soundManager && typeof window.soundManager.playRandomIntroMusic === 'function') {
                                                window.soundManager.resumeAudioContext().then(() => {
                                                    window.soundManager.playRandomIntroMusic();
                                                    window.logger?.audio('Music started after delayed initialization');
                                                });
                                            }
                                        }, 500);
                                    }
                                }
                            } catch (audioError) {
                                window.logger?.warn('Audio initialization failed:', audioError);
                            }
                            
                            // Add visual feedback
                            startButton.style.opacity = '0.7';
                            startButton.textContent = 'STARTING...';
                            startButton.disabled = true;
                            
                            try {
                                // Simple scene transition using CSS classes
                                const mainMenu = document.getElementById('main-menu');
                                const playerSelection = document.getElementById('player-selection');
                                
                                if (!mainMenu || !playerSelection) {
                                    throw new Error('Required scene elements not found');
                                }
                                
                                // Hide main menu
                                mainMenu.classList.remove('active');
                                mainMenu.classList.add('exiting');
                                
                                // Show player selection after a short delay
                                setTimeout(() => {
                                    mainMenu.style.display = 'none';
                                    playerSelection.style.display = 'block';
                                    playerSelection.classList.add('active');
                                    
                    // Set up player selection buttons with self-contained handlers
                    this.setupPlayerSelectionSelfContained();
                    
                    window.logger?.info('Scene transition completed successfully');
                                }, 500);
                                
                            } catch (error) {
                                window.logger?.error('Failed to start game:', error);
                                
                                // Reset button state
                                startButton.style.opacity = '';
                                startButton.textContent = 'START GAME';
                                startButton.disabled = false;
                                gameStarted = false;
                                
                                // Show user-friendly error
                                alert('Failed to start the game. Please try again or refresh the page.');
                            }
                        };
                        
                        // Simple click handler
                        startButton.addEventListener('click', startGame);
                        
                        // Add global test function for music
                        window.testMusic = () => {
                            window.logger?.info('Manual music test triggered');
                            if (window.soundManager) {
                                window.soundManager.resumeAudioContext().then(() => {
                                    window.soundManager.playRandomIntroMusic();
                                    window.logger?.audio('Manual music test - should be playing now');
                                });
                            } else {
                                window.logger?.error('Sound manager not available for music test');
                            }
                        };
                        
                        window.logger?.info('Start button configured');
                    } else {
                        window.logger?.error('Start button not found');
                    }
                } else {
                    window.logger?.error('Main menu element not found!');
                }
            },
            
            // Initialize 3D scene for enhanced visual effects
            initialize3DScene() {
                try {
                    // Check if THREE.js is available
                    if (typeof THREE === 'undefined') {
                        window.logger?.warn('THREE.js not available, skipping 3D scene');
                        return;
                    }
                    
                    // Initialize the enhanced 3D main menu scene
                    if (window.mainMenuScene && !window.mainMenuScene.initialized) {
                        window.logger?.info('Initializing enhanced 3D scene with particles and line textures');
                        window.mainMenuScene.init();
                    } else if (window.initMainMenuScene) {
                        // Fallback for older initialization
                        window.initMainMenuScene();
                    }
                } catch (error) {
                    window.logger?.warn('3D scene initialization failed:', error);
                    // Continue without 3D effects
                }
            },
            
            // Initialize intro sounds system - TIMING OPTIMIZED
            async initializeIntroSounds() {
                try {
                    // **TIMING SAFETY: Only prepare audio system, never auto-start music**
                    if (window.soundManager) {
                        window.logger?.audio('Sound manager ready - preparing perfect timing system');
                        
                        // **TIMING APPROACH: Only prepare audio context and system, no music yet**
                        // Intro music will ONLY be started by the start button for perfect timing
                        window.logger?.audio('Perfect timing system prepared - awaiting start button press');
                        
                        // Pre-prime the audio system for immediate perfect playback when needed
                        if (typeof window.soundManager.primeAudioSystemForPerfectPlayback === 'function') {
                            window.soundManager.primeAudioSystemForPerfectPlayback();
                        }
                        
                    } else {
                        window.logger?.info('Sound manager not available yet for intro sounds');
                        
                        // Retry if sound manager isn't ready
                        setTimeout(() => {
                            this.initializeIntroSounds();
                        }, 500);
                    }
                } catch (error) {
                    window.logger?.warn('Failed to initialize intro sounds:', error);
                }
            },
            
            // Set up volume controls with improved structure
            setupVolumeControls() {
                const helpers = window.gameHelpers;
                const config = window.gameConfig;
                
                const elements = {
                    toggle: document.getElementById('volume-toggle'),
                    control: document.getElementById('volume-control'),
                    close: document.getElementById('close-volume'),
                    mute: document.getElementById('mute-btn'),
                    masterSlider: document.getElementById('master-volume'),
                    sfxSlider: document.getElementById('sfx-volume'),
                    musicSlider: document.getElementById('music-volume')
                };
                
                // Toggle volume panel
                helpers?.addUniversalEventListener(elements.toggle, () => {
                    window.soundManager?.playClick();
                    elements.control?.classList.toggle('show');
                });
                
                // Close volume panel
                helpers?.addUniversalEventListener(elements.close, () => {
                    window.soundManager?.playClick();
                    elements.control?.classList.remove('show');
                });
                
                // Set up sliders
                const setupSlider = (slider, callback) => {
                    if (!slider) return;
                    
                    slider.addEventListener('input', callback);
                    slider.addEventListener('change', callback);
                    
                    // Touch support
                    if (config?.device.isMobile) {
                        slider.addEventListener('touchmove', (e) => e.stopPropagation());
                    }
                };
                
                // Volume sliders
                setupSlider(elements.masterSlider, (e) => {
                    const volume = e.target.value / 100;
                    window.soundManager?.setMasterVolume(volume);
                });
                
                setupSlider(elements.sfxSlider, (e) => {
                    const volume = e.target.value / 100;
                    if (window.soundManager) {
                        window.soundManager.setSFXVolume(volume);
                        window.soundManager.playClick();
                    }
                });
                
                setupSlider(elements.musicSlider, (e) => {
                    const volume = e.target.value / 100;
                    window.soundManager?.setMusicVolume(volume);
                });
                
                // Mute toggle
                helpers?.addUniversalEventListener(elements.mute, () => {
                    if (!window.soundManager) return;
                    
                    const isMuted = window.soundManager.toggleMute();
                    elements.mute.textContent = isMuted ? 'Unmute All' : 'Mute All';
                    elements.mute.style.opacity = isMuted ? '0.6' : '1';
                });
                
                // Set initial slider values
                if (elements.masterSlider) elements.masterSlider.value = (config?.audio.defaultMasterVolume || 0.7) * 100;
                if (elements.sfxSlider) elements.sfxSlider.value = (config?.audio.defaultSfxVolume || 0.8) * 100;
                if (elements.musicSlider) elements.musicSlider.value = (config?.audio.defaultMusicVolume || 0.4) * 100;
            },
            
            // Show error message
            showError(message) {
                if (window.gameManager) {
                    window.gameManager.showError(message);
                } else {
                    alert(message);
                }
            },
            
            // Set up player selection buttons with self-contained handlers
            setupPlayerSelectionSelfContained() {
                const playerSelection = document.getElementById('player-selection');
                if (playerSelection) {
                    const playerButtons = playerSelection.querySelectorAll('.player-btn');
                    const helpers = window.gameHelpers;
                    
                    playerButtons.forEach(button => {
                        const handlePlayerSelection = () => {
                            const count = parseInt(button.getAttribute('data-count'));
                            if (count) {
                                window.logger?.info(`Selected ${count} players`);
                                
                                // Visual feedback
                                playerButtons.forEach(btn => btn.classList.remove('selected'));
                                button.classList.add('selected');
                                
                                // Check if we have saved players for replay with the same count
                                const savedPlayers = window.savedPlayersForReplay || window.lightChallenge?.getSavedPlayerData?.();
                                const savedPlayerCount = savedPlayers?.length || 0;
                                
                                if (savedPlayerCount === count && savedPlayerCount > 0) {
                                    window.logger?.info(`ðŸŽ® Using ${savedPlayerCount} saved players for replay`);
                                    // Proceed directly to color selection with saved data
                                    setTimeout(() => {
                                        this.startColorSelectionWithSavedPlayers(savedPlayers);
                                    }, 500);
                                } else {
                                    // Clear saved players if count doesn't match
                                    window.savedPlayersForReplay = null;
                                    window.logger?.info(`Starting fresh with ${count} players`);
                                    // Proceed to color selection after a short delay
                                    setTimeout(() => {
                                        this.startColorSelectionSelfContained(count);
                                    }, 500);
                                }
                            }
                        };
                        
                        // Multiple event listeners for cross-platform compatibility
                        if (helpers && typeof helpers.addUniversalEventListener === 'function') {
                            helpers.addUniversalEventListener(button, handlePlayerSelection);
                        } else {
                            button.addEventListener('click', handlePlayerSelection);
                            button.addEventListener('touchend', (e) => {
                                e.preventDefault();
                                handlePlayerSelection();
                            });
                        }
                    });
                    
                    window.logger?.info('Player selection buttons configured');
                } else {
                    window.logger?.error('Player selection scene not found');
                }
            },
            
            // Start color selection with saved players (for Play Again functionality)
            startColorSelectionWithSavedPlayers(savedPlayers) {
                try {
                    window.logger?.info(`Starting color selection with ${savedPlayers.length} saved players`);
                    
                    const playerSelection = document.getElementById('player-selection');
                    const colorSelection = document.getElementById('color-selection');
                    
                    if (!playerSelection || !colorSelection) {
                        throw new Error('Required scene elements not found');
                    }
                    
                    // Hide player selection
                    playerSelection.classList.remove('active');
                    playerSelection.classList.add('exiting');
                    
                    // Show color selection after a short delay
                    setTimeout(() => {
                        playerSelection.style.display = 'none';
                        colorSelection.style.display = 'block';
                        colorSelection.classList.add('active');
                        
                        // Set up color selection interface with saved data
                        this.setupColorSelectionWithSavedData(savedPlayers);
                        
                        window.logger?.info('Color selection scene activated with saved players');
                    }, 500);
                    
                } catch (error) {
                    window.logger?.error('Failed to start color selection with saved players:', error);
                    alert('Failed to start game. Please try again.');
                }
            },
            
            // Start color selection with self-contained functionality
            startColorSelectionSelfContained(playerCount) {
                try {
                    window.logger?.info(`Starting color selection for ${playerCount} players`);
                    
                    const playerSelection = document.getElementById('player-selection');
                    const colorSelection = document.getElementById('color-selection');
                    
                    if (!playerSelection || !colorSelection) {
                        throw new Error('Required scene elements not found');
                    }
                    
                    // Hide player selection
                    playerSelection.classList.remove('active');
                    playerSelection.classList.add('exiting');
                    
                    // Show color selection after a short delay
                    setTimeout(() => {
                        playerSelection.style.display = 'none';
                        colorSelection.style.display = 'block';
                        colorSelection.classList.add('active');
                        
                        // Set up color selection interface
                        this.setupColorSelectionSelfContained(playerCount);
                        
                        window.logger?.info('Color selection scene activated');
                    }, 500);
                    
                } catch (error) {
                    window.logger?.error('Failed to start color selection:', error);
                    alert('Failed to start color selection. Please try again.');
                }
            },
            
            // Set up color selection interface with self-contained functionality
            setupColorSelectionSelfContained(playerCount) {
                const colorGrid = document.getElementById('color-grid');
                let confirmButton = document.getElementById('confirm-colors');
                
                if (!colorGrid || !confirmButton) {
                    window.logger?.error('Color selection elements not found');
                    return;
                }

                // Remove existing listeners by replacing the button with a clone
                const newConfirmButton = confirmButton.cloneNode(true);
                confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
                confirmButton = newConfirmButton;
                
                // Available colors
                const availableColors = [
                    { color: '#ff0000', name: 'Red' },
                    { color: '#00ff00', name: 'Green' },
                    { color: '#0080ff', name: 'Blue' },
                    { color: '#ffff00', name: 'Yellow' },
                    { color: '#ff8000', name: 'Orange' },
                    { color: '#8000ff', name: 'Purple' },
                    { color: '#ff0080', name: 'Pink' },
                    { color: '#00ff80', name: 'Cyan' }
                ];
                
                const selectedColors = [];
                const playerNames = [];
                
                // Create color selection interface
                let colorGridHTML = '';
                for (let i = 0; i < playerCount; i++) {
                    colorGridHTML += `
                        <div class="player-color-row">
                            <div class="player-name-section">
                                <input type="text" 
                                       class="player-name-input" 
                                       data-player="${i}"
                                       placeholder="Enter Player ${i + 1} Name"
                                       value="Player ${i + 1}"
                                       maxlength="20"
                                       autocomplete="off">
                            </div>
                            <div class="color-options" data-player="${i}">
                                ${availableColors.map((color, index) => `
                                    <div class="color-option" 
                                         data-color="${color.color}" 
                                         data-name="${color.name}"
                                         data-index="${index}"
                                         style="background-color: ${color.color};"
                                         title="${color.name}">
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                
                colorGrid.innerHTML = colorGridHTML;
                
                // Set up name input handlers
                const nameInputs = colorGrid.querySelectorAll('.player-name-input');
                nameInputs.forEach(input => {
                    const playerIndex = parseInt(input.getAttribute('data-player'));
                    playerNames[playerIndex] = input.value;
                    
                    input.addEventListener('input', () => {
                        const name = input.value.trim();
                        playerNames[playerIndex] = name || `Player ${playerIndex + 1}`;
                        this.checkColorSelectionComplete(selectedColors, playerCount, confirmButton);
                    });
                });
                
                // Set up color option click handlers
                const colorOptions = colorGrid.querySelectorAll('.color-option');
                
                const updateAllColorStates = () => {
                    const helpers = window.gameHelpers;
                    colorOptions.forEach(opt => {
                        const optColor = opt.getAttribute('data-color');
                        const playerOptionsContainer = opt.closest('.color-options');
                        const optPlayerIndex = parseInt(playerOptionsContainer.getAttribute('data-player'));
                        
                        // Is this color selected by THIS player?
                        const isSelectedByThisPlayer = selectedColors[optPlayerIndex]?.color === optColor;
                        
                        // Is this color selected by ANY OTHER player?
                        const isSelectedByOtherPlayer = selectedColors.some((sc, idx) => 
                            idx !== optPlayerIndex && sc?.color === optColor
                        );
                        
                        if (isSelectedByThisPlayer) {
                            opt.classList.add('selected');
                            opt.classList.remove('disabled');
                        } else if (isSelectedByOtherPlayer) {
                            opt.classList.remove('selected');
                            opt.classList.add('disabled');
                        } else {
                            opt.classList.remove('selected');
                            opt.classList.remove('disabled');
                        }

                        // Update name box color if selected
                        const nameInput = colorGrid.querySelector(`.player-name-input[data-player="${optPlayerIndex}"]`);
                        if (nameInput) {
                            const playerColor = selectedColors[optPlayerIndex]?.color;
                            if (playerColor) {
                                nameInput.style.backgroundColor = playerColor;
                                nameInput.style.color = helpers?.getContrastColor(playerColor) || '#ffffff';
                                nameInput.style.borderColor = '#ffffff';
                            } else {
                                nameInput.style.backgroundColor = '';
                                nameInput.style.color = '';
                                nameInput.style.borderColor = '';
                            }
                        }
                    });
                };

                colorOptions.forEach(option => {
                    const helpers = window.gameHelpers;
                    const handleColorSelection = () => {
                        const playerIndex = parseInt(option.closest('.color-options').getAttribute('data-player'));
                        const color = option.getAttribute('data-color');
                        const colorName = option.getAttribute('data-name');
                        
                        // Check if color is already selected by another player
                        if (selectedColors.some((sc, index) => sc && sc.color === color && index !== playerIndex)) {
                            if (window.soundManager) window.soundManager.playWarning();
                            return;
                        }
                        
                        // Select this color for this player
                        selectedColors[playerIndex] = { color, name: colorName };
                        if (window.soundManager) window.soundManager.playSelect();
                        
                        // Update all visual states correctly
                        updateAllColorStates();
                        
                        this.checkColorSelectionComplete(selectedColors, playerCount, confirmButton);
                    };
                    
                    if (helpers && typeof helpers.addUniversalEventListener === 'function') {
                        helpers.addUniversalEventListener(option, handleColorSelection);
                    } else {
                        option.addEventListener('click', handleColorSelection);
                        option.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            handleColorSelection();
                        });
                    }
                });

                // Set up confirm button
                const handleConfirm = async () => {
                    // Prevent multiple clicks
                    if (confirmButton.disabled) return;
                    confirmButton.disabled = true;

                    // **PERFECT FADE OUT when all colors are assigned**
                    if (window.soundManager && window.soundManager.introMusic) {
                        window.logger?.audio('All colors assigned - perfectly fading out intro music');
                        window.soundManager.stopIntroMusic(); // This includes smooth fade out
                    }

                    const playerData = [];
                    for (let i = 0; i < playerCount; i++) {
                        playerData.push({
                            name: playerNames[i] || `Player ${i + 1}`,
                            color: selectedColors[i]?.color || '#ffffff'
                        });
                    }

                    window.logger?.info('Starting role assignment with players:', playerData);

                    // **AUTOMATICALLY PROCEED TO ROLE ASSIGNMENT (voice instructions will be spoken there)**
                    await this.startRoleAssignmentDirectly(playerData);
                };
                
                const helpers = window.gameHelpers;
                if (helpers && typeof helpers.addUniversalEventListener === 'function') {
                    helpers.addUniversalEventListener(confirmButton, handleConfirm);
                } else {
                    confirmButton.addEventListener('click', handleConfirm);
                    confirmButton.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        handleConfirm();
                    });
                }
                
                window.logger?.info('Color selection interface configured');
            },
            
            // Set up color selection with saved player data for Play Again functionality
            setupColorSelectionWithSavedData(savedPlayers) {
                try {
                    window.logger?.info(`Setting up color selection with ${savedPlayers.length} saved players:`, savedPlayers);
                    
                    const colorGrid = document.getElementById('color-grid');
                    let confirmButton = document.getElementById('confirm-colors');
                    
                    if (!colorGrid || !confirmButton) {
                        window.logger?.error('Color selection elements not found');
                        return;
                    }

                    // Remove existing listeners by replacing the button with a clone
                    const newConfirmButton = confirmButton.cloneNode(true);
                    confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
                    confirmButton = newConfirmButton;
                    
                    // Available colors
                    const availableColors = [
                        { color: '#ff0000', name: 'Red' },
                        { color: '#00ff00', name: 'Green' },
                        { color: '#0080ff', name: 'Blue' },
                        { color: '#ffff00', name: 'Yellow' },
                        { color: '#ff8000', name: 'Orange' },
                        { color: '#8000ff', name: 'Purple' },
                        { color: '#ff0080', name: 'Pink' },
                        { color: '#00ff80', name: 'Cyan' }
                    ];
                    
                    const selectedColors = [];
                    const playerCount = savedPlayers.length;
                    
                    // Create color selection interface with saved data pre-populated
                    let colorGridHTML = '';
                    for (let i = 0; i < playerCount; i++) {
                        const savedPlayer = savedPlayers[i];
                        selectedColors.push({
                            color: savedPlayer.color,
                            colorName: savedPlayer.colorName,
                            name: savedPlayer.name
                        });
                        
                        colorGridHTML += `
                            <div class="player-color-row">
                                <div class="player-name-section">
                                    <label for="player-${i + 1}-name">Player ${i + 1}:</label>
                                    <input type="text" 
                                           id="player-${i + 1}-name" 
                                           class="player-name-input" 
                                           placeholder="Enter name"
                                           value="${savedPlayer.name}"
                                           maxlength="20">
                                </div>
                                <div class="color-options" data-player="${i}">
                                    ${availableColors.map(colorOption => `
                                        <div class="color-option ${colorOption.color === savedPlayer.color ? 'selected' : ''}" 
                                             data-color="${colorOption.color}" 
                                             data-name="${colorOption.name}"
                                             style="background-color: ${colorOption.color};"
                                             title="${colorOption.name}">
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }
                    
                    colorGrid.innerHTML = colorGridHTML;
                    
                    // Function to update all visual states
                    const updateAllColorStates = () => {
                        const helpers = window.gameHelpers;
                        const colorOptions = colorGrid.querySelectorAll('.color-option');
                        colorOptions.forEach(opt => {
                            const optColor = opt.getAttribute('data-color');
                            const optPlayerIndex = parseInt(opt.closest('.color-options').getAttribute('data-player'));
                            
                            // Is this color selected by THIS player?
                            const isSelectedByThisPlayer = selectedColors[optPlayerIndex]?.color === optColor;
                            
                            // Is this color selected by ANY OTHER player?
                            const isSelectedByOtherPlayer = selectedColors.some((sc, idx) => 
                                idx !== optPlayerIndex && sc?.color === optColor
                            );
                            
                            if (isSelectedByThisPlayer) {
                                opt.classList.add('selected');
                                opt.classList.remove('disabled');
                            } else if (isSelectedByOtherPlayer) {
                                opt.classList.remove('selected');
                                opt.classList.add('disabled');
                            } else {
                                opt.classList.remove('selected');
                                opt.classList.remove('disabled');
                            }

                            // Update name box color if selected
                            const nameInput = document.getElementById(`player-${optPlayerIndex + 1}-name`);
                            if (nameInput) {
                                const playerColor = selectedColors[optPlayerIndex]?.color;
                                if (playerColor) {
                                    nameInput.style.backgroundColor = playerColor;
                                    nameInput.style.color = helpers?.getContrastColor(playerColor) || '#ffffff';
                                    nameInput.style.borderColor = '#ffffff';
                                } else {
                                    nameInput.style.backgroundColor = '';
                                    nameInput.style.color = '';
                                    nameInput.style.borderColor = '';
                                }
                            }
                        });
                    };

                    // Add event listeners for color selection
                    colorGrid.addEventListener('click', (e) => {
                        if (e.target.classList.contains('color-option')) {
                            const playerIndex = parseInt(e.target.closest('.color-options').dataset.player);
                            const color = e.target.dataset.color;
                            const colorName = e.target.dataset.name;
                            const nameInput = document.getElementById(`player-${playerIndex + 1}-name`);
                            
                            // Check if color is already selected by another player
                            const isColorTaken = selectedColors.some((selected, index) => 
                                selected && selected.color === color && index !== playerIndex
                            );
                            
                            if (isColorTaken) {
                                if (window.soundManager) window.soundManager.playWarning();
                                return;
                            }
                            
                            // Update selected colors
                            selectedColors[playerIndex] = {
                                color: color,
                                colorName: colorName,
                                name: nameInput.value.trim() || `Player ${playerIndex + 1}`
                            };
                            
                            if (window.soundManager) window.soundManager.playSelect();
                            
                            // Update all visual states
                            updateAllColorStates();
                            
                            // Check if all colors are selected
                            this.checkColorSelectionComplete(selectedColors, playerCount, confirmButton);
                        }
                    });

                    // Initial state update
                    updateAllColorStates();
                    
                    // Add event listeners for name inputs
                    for (let i = 0; i < playerCount; i++) {
                        const nameInput = document.getElementById(`player-${i + 1}-name`);
                        if (nameInput) {
                            nameInput.addEventListener('input', () => {
                                if (selectedColors[i]) {
                                    selectedColors[i].name = nameInput.value.trim() || `Player ${i + 1}`;
                                    this.checkColorSelectionComplete(selectedColors, playerCount, confirmButton);
                                }
                            });
                        }
                    }
                    
                    // Setup confirm button for game restart
                    confirmButton.addEventListener('click', async () => {
                        // Prevent multiple clicks
                        if (confirmButton.disabled) return;
                        confirmButton.disabled = true;

                        window.logger?.info('ðŸŽ® Starting replay game with updated player data');
                        
                        if (window.soundManager) window.soundManager.playClick();
                        
                        // Prepare player data for game restart
                        const playersData = selectedColors.slice(0, playerCount).map((player, index) => ({
                            name: player.name || `Player ${index + 1}`,
                            color: player.color,
                            colorName: player.colorName
                        }));
                        
                        window.logger?.info('ðŸŽ® Replay player data prepared:', playersData);
                        
                        // Start the game with updated data
                        try {
                            if (window.gameManager) {
                                window.gameManager.resetForReplay();
                                await window.gameManager.setupGame(playerCount, playersData);
                                window.logger?.info('âœ… Replay game started successfully');
                            } else {
                                throw new Error('Game manager not found');
                            }
                        } catch (error) {
                            window.logger?.error('âŒ Error starting replay game:', error);
                            alert('Error starting replay game. Please refresh the page.');
                        }
                    });
                    
                    // Show confirm button immediately since all data is pre-populated
                    this.checkColorSelectionComplete(selectedColors, playerCount, confirmButton);
                    
                    window.logger?.info('âœ… Color selection setup complete with saved data');
                    
                } catch (error) {
                    window.logger?.error('âŒ Error setting up color selection with saved data:', error);
                    alert('Error setting up replay. Please refresh the page.');
                }
            },
            
            // Check if color selection is complete
            checkColorSelectionComplete(selectedColors, playerCount, confirmButton) {
                const allColorsSelected = selectedColors.length >= playerCount && 
                                        selectedColors.slice(0, playerCount).every(color => color && color.color);
                
                if (allColorsSelected) {
                    confirmButton.style.display = 'block';
                    confirmButton.disabled = false;
                } else {
                    confirmButton.style.display = 'none';
                    confirmButton.disabled = true;
                }
            },
            
            // Start the actual game with players
            startGameWithPlayersSelfContained(playerData) {
                try {
                    window.logger?.info('Starting game with player data:', playerData);
                    
                    // Perfect fade out of intro music as game starts
                    if (window.soundManager && window.soundManager.introMusic) {
                        window.logger?.audio('Perfect fade out of intro music as game starts');
                        window.soundManager.stopIntroMusic(); // This includes smooth fade out
                    }
                    
                    // Also stop any ambient background music from intro
                    if (window.soundManager && window.soundManager.backgroundMusic) {
                        window.logger?.audio('Stopping ambient background music as game starts');
                        window.soundManager.stopBackgroundMusic();
                    }
                    
                    // Show brief transition message
                    const colorSelection = document.getElementById('color-selection');
                    const challengeContainer = document.getElementById('challenge-container');
                    
                    if (colorSelection && challengeContainer) {
                        colorSelection.classList.remove('active');
                        colorSelection.style.display = 'none';
                        
                        challengeContainer.style.display = 'block';
                        challengeContainer.classList.add('active');
                        challengeContainer.innerHTML = `
                            <div class="game-starting">
                                <h2>Game Starting...</h2>
                                <p>Setting up the challenge for ${playerData.length} players</p>
                                <div class="player-list">
                                    ${playerData.map(player => `
                                        <div class="player-item" style="color: ${player.color}">
                                            ${player.name}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                        
                        // Wait for main game system to be ready and start properly
                        this.waitForGameSystemAndStart(playerData);
                    }
                    
                } catch (error) {
                    window.logger?.error('Failed to start game:', error);
                    alert('Failed to start the game. Please refresh and try again.');
                }
            },
            
            // Wait for game system to be ready and start the game properly
            async waitForGameSystemAndStart(playerData) {
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max wait
                
                const checkAndStart = async () => {
                    attempts++;
                    
                    // Check if game manager is ready
                    if (window.gameManager && typeof window.gameManager.startGame === 'function') {
                        window.logger?.info('Game manager ready, starting game');
                        
                        // Set up player data in the format the existing system expects
                        window.gameManager.players = playerData.map((player, index) => ({
                            id: index + 1,
                            name: player.name,
                            color: player.color,
                            isActive: true
                        }));
                        
                        // Start the game using the existing system
                        window.gameManager.startGame();
                        return;
                    }
                    
                    // Check if there's a global startGame function
                    if (window.startGame && typeof window.startGame === 'function') {
                        window.logger?.info('Global startGame function found, starting game');
                        window.startGame(playerData);
                        return;
                    }
                    
                    // If we haven't found the game system yet and haven't exceeded max attempts
                    if (attempts < maxAttempts) {
                        setTimeout(checkAndStart, 100);
                        return;
                    }
                    
                    // If we can't find the main game system, try to start challenges directly
                    window.logger?.warn('Main game system not found, attempting direct challenge start');
                    this.startChallengesDirectly(playerData);
                };
                
                // Start checking
                checkAndStart();
            },
            
            // Direct role assignment start after voice instructions
            async startRoleAssignmentDirectly(playerData) {
                try {
                    window.logger?.info('Starting role assignment directly after voice instructions');

                    // Hide color selection and show role assignment
                    const colorSelection = document.getElementById('color-selection');
                    const challengeContainer = document.getElementById('challenge-container');

                    if (colorSelection && challengeContainer) {
                        colorSelection.classList.remove('active');
                        colorSelection.style.display = 'none';

                        challengeContainer.style.display = 'block';
                        challengeContainer.classList.add('active');

                        // Initialize game manager and role manager
                        if (!window.gameManager && typeof GameManager !== 'undefined') {
                            window.gameManager = new GameManager();
                            window.logger?.info('Game manager initialized for role assignment');
                        }

                        if (window.gameManager && typeof window.gameManager.initializeManagers === 'function') {
                            await window.gameManager.initializeManagers();
                            window.logger?.info('Game managers initialized successfully');
                        }

                        // Start role assignment with the player data
                        if (window.gameManager && window.gameManager.roleManager) {
                            await window.gameManager.roleManager.startRoleAssignment(playerData);
                            window.logger?.info('Role assignment started successfully');
                        } else {
                            throw new Error('Role manager not available');
                        }
                    }

                } catch (error) {
                    window.logger?.error('Failed to start role assignment directly:', error);
                    alert('Failed to start role assignment. Please refresh the page.');
                }
            },

            // Direct challenge start as fallback
            startChallengesDirectly(playerData) {
                try {
                    // Try to start the first challenge if challenge modules are available
                    if (window.firstImpressionsChallenge && typeof window.firstImpressionsChallenge.start === 'function') {
                        window.logger?.info('Starting first impressions challenge directly');

                        // Set up global player data
                        window.players = playerData;

                        // Start the challenge
                        window.firstImpressionsChallenge.start(playerData);
                        return;
                    }

                    // If no challenge modules, show error
                    window.logger?.error('No game system or challenge modules found');

                    const challengeContainer = document.getElementById('challenge-container');
                    if (challengeContainer) {
                        challengeContainer.innerHTML = `
                            <div class="game-starting">
                                <h2>System Error</h2>
                                <p>Game modules are still loading. Please wait a moment and refresh the page.</p>
                                <button onclick="window.location.reload()" style="margin-top: 20px; padding: 15px 30px; background: #00ffff; color: #000; border: none; border-radius: 10px; cursor: pointer; font-size: 1.1rem;">
                                    Refresh Game
                                </button>
                            </div>
                        `;
                    }

                } catch (error) {
                    window.logger?.error('Failed to start challenges directly:', error);
                    alert('Failed to start the game. Please refresh the page.');
                }
            }
        };
        
        // Audio button update function (from root index.html)
        function updateAudioButton(buttonId, enabled) {
            const button = document.getElementById(buttonId);
            if (button) {
                if (enabled) {
                    button.style.backgroundColor = 'rgba(100, 255, 218, 0.2)';
                    button.style.color = 'var(--accent-color)';
                } else {
                    button.style.backgroundColor = 'rgba(255, 107, 157, 0.2)';
                    button.style.color = 'var(--accent-secondary)';
                }
            }
        }

        // Initialize when DOM is ready - mobile compatible
        function initializeApp() {
            if (window.LightChallengeApp && typeof window.LightChallengeApp.init === 'function') {
                window.LightChallengeApp.init();
            } else {
                // Retry if app not ready yet
                setTimeout(initializeApp, 50);
            }
        }
        
        // Determine best time to initialize based on device
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Mobile devices need more time for scripts to load
                const isMobile = /Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(navigator.userAgent);
                const delay = isMobile ? 200 : 50;
                setTimeout(initializeApp, delay);
            });
        } else {
            // DOM already loaded
            const isMobile = /Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(navigator.userAgent);
            const delay = isMobile ? 200 : 50;
            setTimeout(initializeApp, delay);
        }
        
        // Also try to initialize on visibility change (helps with some mobile browsers)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && !window.LightChallengeApp?.initialized) {
                console.log('ðŸ“± Page visible, ensuring app is initialized');
                initializeApp();
            }
        });
        
        // Backup initialization timeout
        setTimeout(() => {
            if (!window.LightChallengeApp?.initialized) {
                console.log('ðŸ“± Backup initialization triggered');
                initializeApp();
            }
        }, 2000);
    </script>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner"></div>
        <p class="loading-text">Preparing The Spy Academy...</p>
    </div>

    <!-- Main Menu Scene -->
    <div id="main-menu" class="scene">
        <div id="three-container" class="three-container"></div>
        <div class="menu-overlay">
            <h1 class="game-title">THE SPY ACADEMY</h1>
            <button id="start-game-btn" class="start-button">START GAME</button>
            
            <!-- Vote Suspicion Skip Option -->
            <div class="skip-voting-container">
                <label class="skip-voting-option">
                    <input type="checkbox" id="skip-voting-checkbox" class="skip-voting-checkbox">
                    <span class="skip-voting-label">Skip Voting Suspicion Scene</span>
                    <span class="skip-voting-description">Play without the initial suspicion voting phase</span>
                </label>
            </div>
        </div>
    </div>

    <!-- Player Selection Scene -->
    <div id="player-selection" class="scene">
        <div class="selection-container">
            <h2 class="selection-title">How many players will be taking on this challenge?</h2>
            <div class="player-count-selector">
                <button class="player-btn" data-count="3">3 Players</button>
                <button class="player-btn" data-count="4">4 Players</button>
                <button class="player-btn" data-count="5">5 Players</button>
                <button class="player-btn" data-count="6">6 Players</button>
                <button class="player-btn" data-count="7">7 Players</button>
                <button class="player-btn" data-count="8">8 Players</button>
            </div>
        </div>
    </div>

    <!-- Color Selection Scene -->
    <div id="color-selection" class="scene">
        <div class="selection-container">
            <h2 class="selection-title">Choose your player colors</h2>
            <div id="color-grid" class="color-grid"></div>
            <button id="confirm-colors" class="confirm-btn" style="display: none;">Begin The Challenge</button>
        </div>
    </div>

    <!-- Challenge Container -->
    <div id="challenge-container" class="scene">
        <!-- Challenge content will be loaded here -->
    </div>

    <!-- Skip Button for Testing -->
    <div id="skip-toggle" class="skip-toggle" title="Skip to Victory (Testing)">â­ï¸</div>
    
    <!-- Fullscreen Toggle Button -->
    <div id="fullscreen-toggle" class="fullscreen-toggle" title="Enter Fullscreen">â›¶</div>

    <!-- Volume Control Interface -->
    <div id="volume-toggle" class="volume-toggle" title="Audio Settings">ðŸ”Š</div>
    <div id="volume-control" class="volume-control">
        <h4>Audio Settings</h4>
        
        <div class="volume-slider-group">
            <label for="master-volume">Master Volume</label>
            <input type="range" id="master-volume" class="volume-slider" min="0" max="100" value="70">
        </div>
        
        <div class="volume-slider-group">
            <label for="sfx-volume">Sound Effects</label>
            <input type="range" id="sfx-volume" class="volume-slider" min="0" max="100" value="80">
        </div>
        
        <div class="volume-slider-group">
            <label for="music-volume">Background Music</label>
            <input type="range" id="music-volume" class="volume-slider" min="0" max="100" value="40">
        </div>
        
        <div class="volume-buttons">
            <button id="mute-btn" class="volume-btn mute-btn">Mute All</button>
            <button id="close-volume" class="volume-btn">Close</button>
        </div>
    </div>

    <!-- Game Over / Victory Screens -->
    <div id="game-over" class="scene">
        <div class="result-container">
            <h2 class="result-title">The Light Has Faded...</h2>
            <p class="result-message">Your team could not overcome the challenge.</p>
            <div class="victory-buttons">
                <button id="gameover-play-again-same" class="continue-btn">ðŸŽ® Play Again With Same Players</button>
                <button id="gameover-start-new" class="restart-btn">ðŸ”„ Start New Game</button>
            </div>
        </div>
    </div>

    <div id="victory" class="scene">
        <div class="result-container">
            <h2 class="result-title">The Light Reveals Its Secrets!</h2>
            <p class="result-message">Congratulations! You have conquered this challenge.</p>
            <div class="victory-buttons">
                <button id="play-again-same-players" class="continue-btn">ðŸŽ® Play Again With Same Players</button>
                <button id="start-new-game" class="restart-btn">ðŸ”„ Start New Game</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <!-- Load utilities first -->
    <script src="js/utils/logger.js"></script>
    <script src="js/utils/config.js"></script>
    <script src="js/utils/helpers.js"></script>

    <!-- Third-party dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <!-- Core game modules -->
    <script src="js/soundManager.js"></script>
    <script src="js/voiceManager.js"></script>
    <script src="js/utils/voiceConfig.js"></script>
    <script src="js/roleManager.js"></script>
    <script src="js/gameManager.js"></script>
    
    <!-- Challenge modules -->
    <script src="js/challenges/firstImpressionsChallenge.js"></script>
    <script src="js/challenges/rockPaperScissorsChallenge.js"></script>
    
    <!-- Main initialization -->
    <script src="js/main.js"></script>
    
    <!-- Service Worker Registration for PWA support -->
    <script>
        // Register service worker for offline support and PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Only register SW if not running from file:// protocol
                if (location.protocol !== 'file:') {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            console.log('âœ… Service Worker registered successfully:', registration.scope);
                        })
                        .catch(error => {
                            console.warn('âš ï¸ Service Worker registration failed:', error);
                            // Service worker failure should not break the app
                        });
                } else {
                    console.log('ðŸ“± Running from file:// protocol, skipping Service Worker registration');
                }
            });
        } else {
            console.log('ðŸ“± Service Worker not supported on this device');
        }
    </script>
</body>
</html>
